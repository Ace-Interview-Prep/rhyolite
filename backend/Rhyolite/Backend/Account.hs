{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE NoMonomorphismRestriction #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeFamilies #-}

{-# OPTIONS_GHC -fno-warn-orphans -Wno-unused-matches #-}
{- NOTE: We add a -Wno-unused-matches because the code generated by groundhog has an unused variable
  GROUNDHOG ERROR -
  src/Rhyolite/Backend/Account.hs:35:1: warning: [-Wunused-matches]
    Defined but not used: ‘p’
  <no location info>: error:
  Failing due to -Werror.
-}

module Rhyolite.Backend.Account where

import Control.Monad.Trans.Except
import Control.Monad.Writer
import Crypto.PasswordStore
import Data.Aeson
import Data.ByteString (ByteString)
import Data.Default
import Data.List.NonEmpty
import Data.Maybe
import Data.String
import Data.Text (Text)
import qualified Data.Text as T
import Data.Text.Encoding
import Data.Time
import Data.Typeable
import Database.Groundhog hiding ((~>))
import Database.Groundhog.Core hiding ((~>))
import Database.Groundhog.Generic.Sql.Functions
import Database.Groundhog.TH (defaultCodegenConfig, groundhog, mkPersist)
import Text.Blaze.Html5 (Html)
import qualified Text.Blaze.Html5 as H
import Text.Blaze.Html5.Attributes as A

import Rhyolite.Backend.DB
import Rhyolite.Backend.Email
import Rhyolite.Backend.Listen
import Rhyolite.Backend.Schema
import Rhyolite.Backend.Schema.TH

import Rhyolite.Account
import Rhyolite.Route
import Rhyolite.Schema
import Rhyolite.Sign

mkPersist defaultCodegenConfig [groundhog|
  - entity: Account
    constructors:
      - name: Account
        uniques:
          - name: emailUnique
            type: index
            fields: [{expr: "lower(account_email::text)"}]
|]

makeDefaultKeyIdInt64 ''Account 'AccountKey

migrateAccount :: PersistBackend m => TableAnalysis m -> Migration m
migrateAccount tableInfo = migrate tableInfo (undefined :: Account)

-- Returns whether a new account had to be created
ensureAccountExists :: (PersistBackend m, SqlDb (PhantomDb m)) => Email -> m (Bool, Id Account)
ensureAccountExists email = do
  nonce <- getTime
  mPrevId <- fmap (listToMaybe . fmap toId) $ project AutoKeyField (lower Account_emailField ==. T.toLower email)
  case mPrevId of
    Just prevId -> return (False, prevId)
    Nothing -> do
      result <- insertByAll $ Account email Nothing (Just nonce)
      case result of
        -- TODO: Better way to handle errors?
        Left _ -> error "ensureAccountExists: Creating account failed"
        Right aid -> do
          let aid' = toId aid
          notifyEntityId NotificationType_Insert aid'
          return (True, aid')

generatePasswordResetToken :: ( PersistBackend m
                              , MonadSign m
                              , Typeable f
                              , ToJSON (f (Id Account))
                              )
                           => f (Id Account)
                           -> m (Signed (PasswordResetToken f))
generatePasswordResetToken aid = do
  nonce <- getTime
  sign $ PasswordResetToken (aid, nonce)

generatePasswordResetTokenFromNonce :: ( MonadSign m
                                       , Typeable f
                                       , ToJSON (f (Id Account))
                                       )
                                    => f (Id Account)
                                    -> UTCTime
                                    -> m (Signed (PasswordResetToken f))
generatePasswordResetTokenFromNonce aid nonce = sign $ PasswordResetToken (aid, nonce)

setAccountPassword :: (PersistBackend m, MonadIO m) => Id Account -> Text -> m ()
setAccountPassword aid password = do
  pw <- makePasswordHash password
  update [ Account_passwordHashField =. Just pw
         , Account_passwordResetNonceField =. (Nothing :: Maybe UTCTime) ]
         (AutoKeyField ==. fromId aid)

makePasswordHash :: MonadIO m => Text -> m ByteString
makePasswordHash pw = do
  salt <- liftIO genSaltIO
  return $ makePasswordSaltWith pbkdf2 (2^) (encodeUtf8 pw) salt 14

resetPassword :: (MonadIO m, PersistBackend m)
              => Id Account
              -> UTCTime
              -> Text
              -> m (Maybe (Id Account))
resetPassword aid nonce password = do
  Just a <- get $ fromId aid
  if account_passwordResetNonce a == Just nonce
    then do
      setAccountPassword aid password
      return $ Just aid
    else return Nothing

login :: (PersistBackend m, SqlDb (PhantomDb m))
      => (Id Account -> m loginInfo)
      -> Email
      -> Text
      -> m (Either LoginError loginInfo)
login toLoginInfo email password = runExceptT $ do
  (aid, a) <- ExceptT . fmap (maybeToEither LoginError_UserNotFound . listToMaybe) $ project (AutoKeyField, AccountConstructor) (lower Account_emailField ==. T.toLower email)
  ph <- ExceptT . return $ maybeToEither LoginError_UserNotFound $ account_passwordHash a
  when (not $ verifyPasswordWith pbkdf2 (2^) (encodeUtf8 password) ph) $ ExceptT $ return $ Left LoginError_InvalidPassword
  lift $ toLoginInfo (toId aid)
  where
    maybeToEither b Nothing = Left b
    maybeToEither _ (Just a) = Right a

loginByAccountId :: (PersistBackend m)
                 => Id Account
                 -> Text
                 -> m (Either LoginError ())
loginByAccountId aid password = runExceptT $ do
  a <- ExceptT . fmap (maybeToEither LoginError_UserNotFound . listToMaybe) $ project AccountConstructor (AutoKeyField ==. fromId aid)
  ph <- ExceptT . return $ maybeToEither LoginError_UserNotFound $ account_passwordHash a
  when (not $ verifyPasswordWith pbkdf2 (2^) (encodeUtf8 password) ph) $ ExceptT $ return $ Left LoginError_InvalidPassword
  return ()
  where
    maybeToEither b Nothing = Left b
    maybeToEither _ (Just a) = Right a
